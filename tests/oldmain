#include "ft_printf.h"
#include <stdlib.h>
#include "libft.h"
#include "directory_info.h"
#include "ft_lstQueue.h"

/*
char *get_filename( char *full_path )
{
	char **chopped_path;

	chopped_path = ft_strsplit( full_path, '/' );
}
*/

t_list *get_dir_list( char *path )
{
	DIR		*directory;
	t_dir_info	dir_info;
	t_list		*node;
	
	directory = opendir( path );
	if ( !directory )
	{
		printf("cannot open directory\n");
		return(NULL);
	}
	path = ft_strjoin( path, "/" );
	if (( dir_info.entry = readdir( directory )) != NULL )
	{	
		dir_info.path = ft_strjoin( path, dir_info.entry -> d_name );
		lstat( dir_info.path, &( dir_info.status ));
		node = ft_lstnew( &dir_info, sizeof( t_dir_info ));
	}
	while(( dir_info.entry = readdir( directory )) != NULL )
	{
		dir_info.path = ft_strjoin( path, dir_info.entry -> d_name );
		lstat( dir_info.path, &( dir_info.status ));
		ft_lstPush( &node, &dir_info, sizeof( t_dir_info ));
	}
	return( node );
}

/* TODO later 
t_list *rev_list( t_list *node )
{
	t_list *new;
	new = ft_lstnew( 
	return( new );
}
void	print_list( t_list *head )
{
	while ( head )
	{
	//	if ( T_NODE( t_dir_info*, head, entry -> d_name )[0] != '.' )
	//		printf("%s  ", T_NODE( t_dir_info*, head, entry -> d_name ));
	//	printf("%ld\n", T_NODE( t_dir_info*, head, status.st_mtim.tv_sec ));
		printf("%s\n", ((char*)(head -> content))); 
		head = head -> next;
	}
	printf("\n");
}
void print_list( t_list *head )
{
	char *str;
	while (( str = ( char* )( ft_lstPop( &head ))))
		printf( "%s\n", str );
}
*/



int	cmp_mtim( void *a, void *b )
{
	return( (((t_dir_info*)a) -> status).st_mtim.tv_sec <=
		(((t_dir_info*)b) -> status).st_mtim.tv_sec );
}
int	compare_num( void *a, void *b )
{	
	return( *((int*)a) >= *((int*)b) );
}

int	wrapper( void *a, void *b )
{	
	char *str1;
	char *str2;
	
	str1 = (((t_dir_info*)a) -> entry) -> d_name;
	str2 = (((t_dir_info*)b) -> entry) -> d_name;
	int t = ft_strcmp(str1, str2);
	if ( t < 0 )
		return(0);
	if ( t == 0 || t > 0 ) 
		return(1);
	return( t );
}

void print_list( t_lstQ *queue )
{
	char *str;
	
	while(( str = (( char* )( ft_lstDQ( queue )))))
		printf("%s\n", str);
}

int main( int ac, char **av )
{
	int values[ ] = { 3, 2, 4, 5, 4, 8, 5, 1, 9, 0 };
	char *strings[ ] = { "c third", "a first", "b second" };
	t_lstQ queue = ft_newlstQueue( );
	//int len = sizeof(values) / sizeof(values[0]);
	int len = sizeof(strings) / sizeof(strings[0]);
	//int len = 3;
	int i = 0;
	//t_list *node = ft_lstnew( values, sizeof( values[0] ) );
	//t_list *node = ft_lstnew( *strings, sizeof( strings[0] ) );
	while ( i < len )
	{
		//ft_lstPush( &node, *(strings + i), sizeof( strings[i] ));
		ft_lstQueue( &queue, *(strings + i), sizeof( strings[i] ));
		i++;
	}
//	mergeSort( &node, &wrapper );
	print_list( &queue );
	return( 0 );
}
/*
int main( int ac, char **av )
{
	t_list *node = get_dir_list( "./test" );
	lstMergeSort( &node, &cmp_mtim );
	print_list( node );
	//printf("%s\n", T_NODE( t_dir_info*,node, path ));
	//printf("%s\n", (( t_dir_info* )( node -> content )) -> path );
	return(0);
}

void	ft_lstPush( t_list **alst, void const *content, size_t content_size )
{
	ft_lstadd( alst, ft_lstnew( content, content_size ) );
}

void	dummy_del( void *content, size_t size )
{
	return;
}

void	*ft_lstPop( t_list **alst)
{
	void *temp;
	temp = (*alst) -> content;
	(*alst) = (*alst) -> next;
	ft_lstdelone( alst, &dummy_del ); 
	return( temp );
}
int main(int ac, char **av)
{

	t_his first;
	first.name = "what the actual fuck";

	t_his second;
	second.name = "nani the fuck";

	t_his third;
	third.name = " how about you piss off";
	
	t_list *node = ft_lstnew( &first, sizeof(t_his) ); 
	t_list *node_two = ft_lstnew( &second, sizeof(t_his) );


//	printf("%s\n", ((t_his*)(node -> content)) -> name);

	ft_lstPush( &node, &second, sizeof(t_his) );
	ft_lstPush( &node, &third, sizeof(t_his) );
	
	printf("%s\n", ((t_his*)(ft_lstPop( &node ))) -> name );
	
//	print_list( node );
		

//	ft_lstadd( &node, node_two);

//	printf("%s\n", ((t_his*)(node -> content)) -> name);

//	printf("%s\n", ((t_his*)((*head) -> content)) -> name );
	

	
	return(0);
}
*/
